
/* START OF TEMPLATE */
/* VALUES ARE NOT CASE SENSITIVE. */
/* DELETE COMMENTS TO CONDENSE FILE AND IMPROVE READIBILITY. */
/* DON'T DELETE PARAMETERS, EVEN IF THEY ARE ASSIGNED TO NULL VALUES. */

libname indata'\\edu\special$\USI_CHESSN_VET\Input Files';
libname outdata '\\edu\special$\USI_CHESSN_VET\Output Files';



%let MACRO_LOCATION=\\edu\special$\USI_CHESSN_VET\\D-MAC 2.3.sas;

/* The folder and file name of the D-MAC macro, for example \\sascompmd\SASData\C231\Data Linking\D-MAC\V2.3\D-MAC 2.3.sas. */




%let INPUT_FOLDER_1=\\edu\special$\USI_CHESSN_VET\Input Files;

/* The folder containing the smaller of the two SAS datasets to be linked: INPUT_DATASET_1. */




%let INPUT_FOLDER_2=\\edu\special$\USI_CHESSN_VET\Input Files;

/* The folder containing the bigger of the two SAS datasets to be linked: INPUT_DATASET_2. */




%let INPUT_DATASET_1=file_a;

/* The name of the smaller SAS dataset to be linked. */




%let INPUT_DATASET_2=file_b;

/* The name of the bigger SAS dataset to be linked. */




%let OUTPUT_FOLDER=\\edu\special$\USI_CHESSN_VET\Output Files;

/* The folder to store the output files. */




%let OUTPUT_LABEL=example3;

/* A short label to be appended to the names of the output files. */




%let WORKING_FOLDER=\\edu\special$\USI_CHESSN_VET\Working Files;

/* A folder with sufficient space to temporarily store the working datasets while the macro is running.  This must be different to the above 
folders because it is cleared of all SAS files at the start and end of each macro run. */




%let ID_1=CHESSN;

/* The name of the primary identifier on INPUT_DATASET_1.  It identifies the people/units to be linked and is not necessarily unique in 
INPUT_DATASET_1.  This allows for multiple versions of the same person to be in INPUT_DATASET_1.  For example, there may be five records for
each value of ID_1 to allow for changes in linking variables (such as change of address) over five years. */




%let ID_2=Usi;

/* The name of the primary identifier on INPUT_DATASET_2.  It identifies the people/units to be linked and is not necessarily unique in 
INPUT_DATASET_2.  The name of this variable in INPUT_DATASET_2 must be different to the name of ID_1 in INPUT_DATASET_1. */




%let SECONDARY_ID_1=;

/* The name of an optional secondary identifier on INPUT_DATASET_1.  It must be unique within each value of ID_1 on INPUT_DATASET_1. */




%let SECONDARY_ID_2=;

/* The name of an optional secondary identifier on INPUT_DATASET_2. It must be unique within each value of ID_2 on INPUT_DATASET_2.  The name 
of this variable in INPUT_DATASET_2 must be different to the name of SECONDARY_ID_1 in INPUT_DATASET_1. */




%let LINKING_VARIABLES_1=FirstName FirstName FamilyName FamilyName DateOfBirth;

/* The names of the linking variables on INPUT_DATASET_1.  Some variables might be listed more than once, see explanation under 
COMPARISON_NAMES. */




%let LINKING_VARIABLES_2=FirstName FirstName FamilyName FamilyName DateOfBirth;

/* The names of the linking variables on INPUT_DATASET_2 with the first variable of LINKING_VARIABLES_1 corresponding to the first variable of 
LINKING_VARIABLES_2 and the second variable of LINKING_VARIABLES_1 corresponding to the second variable of LINKING_VARIABLES_2 and so on.  The 
names of corresponding variables in the two lists don't need to be the same and the corresponding variables don't need to be in the same 
format.  For example, age may be a SAS numeric variable on INPUT_DATASET_1 that corresponds to a SAS character variable called agep on 
INPUT_DATASET_2. However it is recommended that leading zeros are removed from agep. */




%let LINKING_VARIABLE_COMPARATORS=exact levenshtein1 exact levenshtein1 exact;

/* A list of comparators corresponding to the pairs of linking variables in LINKING_VARIABLES_1 and LINKING_VARIABLES_2.  This list must 
contain the same number of items as LINKING_VARIABLES_1 and LINKING_VARIABLES_2.  Each item in the list is either exact, numeric# or missing.  

Exact: The pair of records must agree exactly on the two linking variables for the pair to be considered as agreeing on these variables.

Winkler#: This comparator will consider a pair to agree on two linking variables if their Winkler score is greater than or equal to #, where #
is any number between 0 and 1.  For example, if the variable fname on INPUT_DATASET_1 is compared with variable first_name on INPUT_DATASET_2 
using winkler.85 (or winkler0.85), then pairs with a fname to first_name Winkler score of 0.85 or more will be considered to agree on these 
variables.

Levenshtein#: A fast alternative to the Winkler comparator.  This comparator will consider a pair to agree on two linking variables if the 
Levenshtein distance (computed with the complev SAS function) between them is less than or equal to #, where # is any positive integer.

Damerau#: Another fast alternative to the Winkler comparator that is also useful for detecting transpositional typing errors in names.  This 
comparator will consider a pair to agree on two linking variables if the Damerau-Levenshtein distance between them is less than or equal to #,
where # is any positive integer.

Numeric#: This comparator will consider a pair to agree on two linking variables if their absolute numeric difference is less than or equal to 
#, where # is any positive number.  For example, if the variable age on INPUT_DATASET_1 is compared with variable agep on INPUT_DATASET_2 
using numeric1, then pairs with an absolute difference of one or less between age and agep will be considered to agree on these variables.  
Records whose linking variable values don't contain any numeric characters or contain any non numeric characters will have their linking 
variable value set to missing and will not agree with any records.  However, records whose linking variable values have an @ as their first 
character will have their linking variable value set to 9999999 so that pairs can agree on 'Not Applicable'.  

Missing: The pair of records must have a missing value in one or both of the linking variables for the pair to be considered as agreeing on 
these variables. Recognised missing values on the input datasets are any SAS missing values or blank fields.  If M_PROBABILITIES_GLOBAL and 
U_PROBABILITIES_GLOBAL contain probabilities, then the missing comparator becomes a 'missing or exactly agree' comparator to improve the 
performance of the formula used to estimate the precision. */




%let COMPARISON_NAMES=FRSTNM FRSTNMl_1 FMLYNM FMLYNMl_1 DOB;

/* A list of user defined names for the above pairs of linking variables.  This list must also contain the same number of items as 
LINKING_VARIABLES_1.  For example, the item corresponding to age in LINKING_VARIABLES_1 and agep in LINKING_VARIABLES_2 using the exact 
comparator may be called age_0 with the 0 indicating that no difference between the two age variables will be tolerated.  Another item in the
list may also correspond to the same linking variables age and agep but instead be using the numeric1 comparator, with this item being called
age_1.  Here, the pairs of age variables are involved with two different comparators and would need to be listed twice in LINKING_VARIABLES_1 
and LINKING_VARIABLES_2.  An example of these four lists in this situation is

LINKING_VARIABLES_1 = 			meshblock	sa1			age		age			sex;
LINKING_VARIABLES_2 = 			mbusual		sa1usual	agep	agep		sexp;
LINKING_VARIABLE_COMPARATORS =	exact		exact		exact	numeric1	exact;
COMPARISON_NAMES = 				mb			sa1			age_0	age_1		sex;
 
Important: In COMPARISON_NAMES, all names that appear in FILTER_VARIABLES must be listed after all names that don't appear in 
FILTER_VARIABLES. */




%let VARIABLE_LENGTHS=11 11 11 11 11;

/* An optional list of space to allocate to each linking variable in the lists above.  This option can save time spent on reading and merging
the datasets.  For each linking variable comparison, enter the wider column of INPUT_DATASET_1 and INPUT_DATASET_2.  For example if meshblock
on the two datasets contains 11 digits, set the list item that corresponds to the meshblock comparison to 11, even if meshblock was in numeric 
BEST8 format.  If the list is blank, all entries will default to 11. */




%let M_PROBABILITIES_GLOBAL=;
%let U_PROBABILITIES_GLOBAL=;

/* Optional lists of global m and u probabilities for each comparison in COMPARISON_NAMES.  These will be used to estimate the precision of 
each pass and the linked dataset.  To improve the performance of the formula used to estimate the precision, the missing comparator will be 
applied as the 'exactly agree or missing' comparator.  Therefore with variable comaparisons that use the missing comparator, the m and u 
probabilities should correspond to the chance of observing exact agreement or missing, that is by using P(exact agreement | match status) + 
P(missing on one or both files | match status).

For variables that use the exact comparator, there is the option of accounting for frequency based effects.  This is useful for linking 
variables with skewed distributions such as Country of Birth or Language.  To use the frequency based option for a linking variable that uses
the exact comparator, enter f (instead of its u probability) at its position in the U_PROBABILITIES_GLOBAL list.

The above two lists usually contain global probabilities.  However if a variable is used in many passes or a large proportion of the total 
links are expected to be assigned in passes that use this variable and agreement on this variable significantly alters the probability of
agreement on the other variables that are used with it in the same passes, then the accuracy of the precision estimates could be improved by 
using probabilities conditional upon agreement on this variable.  For example, if all passes contain one of the geography variables MB, SA1 or 
SA2, then consider using probabilities conditional on agreement on SA1 for the non geography variables while leaving the probabilities for the
geography variables as global.

If M_PROBABILITIES_GLOBAL and U_PROBABILITIES_GLOBAL contain probabilities and ORDER_PASSES_BY is blank, the macro will estimate precision and 
rank the passes in descending order of the uniqueness rate subject to FILTER_VARIABLES and PRIORITIES.  To instead rank the passes in 
descending order of the estimated precision, set ORDER_PASSES_BY=precision.  To rank the passes in the order they were entered in PASSES, set 
ORDER_PASSES_BY=passes. */




%let OVERLAP=;

/* This is ignored if M_PROBABILITIES or U_PROBABILITIES are blank.  This is the proportion of records on INPUT_DATASET_1 that are expected to
have a matching record on INPUT_DATASET_2.  If this is blank, it defaults to 1. */




%let PASSES=;

/* If this is blank, the passes will be automatically generated.  Otherwise, the passes can be manually specified using only the names 
appearing in COMPARISON_NAMES.  Separate each pass by a +.  An example of running four passes with the above linking variables is

PASSES =	mb			age_0			sex+
		 	mb					age_1	sex+
		 		sa1		age_0			sex+
		 		sa1				age_1	sex; 

Tabs may be used as above to improve readability. If the same pass is accidentally entered more than once, D-MAC will run it only once.

If the length of PASSES= exceeds 65,534 characters, the passes must instead be specified (one pass per line) in a txt file.  The text file
location is specified in PASSES=.  For example, 

PASSES=\\sascompmd\SASData\C231\Data Linking\D-MAC\V2.1\Examples\Input Files\Passes for Example 9.txt;  

In the text file, + may be entered at the end of each line but this isn't necessary. */




%let ORDER_PASSES_BY=;

/* If ORDER_PASSES_BY is blank, the macro will rank the passes in descending order of the pass uniqueness rate subject to FILTER_VARIABLES and 
PRIORITIES.

If ORDER_PASSES_BY is any non blank value other than passes or precision, the macro will rank the passes in descending order of the pass 
uniqueness rate subject to FILTER_VARIABLES and PRIORITIES.

If ORDER_PASSES_BY=passes and PASSES is not blank, the macro will rank the passes in the order that they appear in PASSES.  Otherwise if PASSES
is blank, the macro will rank the passes in descending order of the pass uniqueness rate subject to FILTER_VARIABLES and PRIORITIES.

If ORDER_PASSES_BY=precision and GLOBAL_M_PROBABILITIES and GLOBAL_U_PROBABILITIES are not blank, the macro will rank the passes in descending 
order of the estimated First Pass Precision (which is based on GLOBAL_M_PROBABILITIES, GLOBAL_U_PROBABILITIES and OVERLAP). */




%let FILTER_VARIABLES=;

/* This is ignored if the ORDER_PASSES_BY=passes or the ORDER_PASSES_BY=precision options are used.  If FILTER_VARIABLES, ORDER_PASSES_BY and
PRIORITIES are blank, the macro ranks the passes in descending order of the pass uniqueness rate.  To use the FILTER_VARIABLES parameter, enter 
a list of the poorer quality (or filter) linking variables using their names as they appear in COMPARISON_NAMES.  With this setting, the 
macro divides all the passes into groups based on which non filter variables (or core linking variables) are used.  Within each group, the 
passes that use one or more filter variables receive a donated uniqueness rate from the pass in that group that uses just the core linking 
variables.  In 'auto pass mode', if the pass that uses just the core linking variables wasn't run because it wasn't discriminating enough for
the given value of MIN_BLOCK_NO, no donor uniqueness rate will be available, so the passes that use the filter variables in that group will not 
run.  This deletion of passes doesnâ€™t occur if the passes are manually specified at PASSES=.  Where a parent pass is not specified, it is 
assumed that the data linker decided not to apply filtering here, the orphan passes are kept and their original uniqueness rates are used.  
Using the FILTER_VARIABLES parameter effectively prevents the filter variables from contributing to the uniqueness rate of a pass and the 
filter variables are only used to add extra uniqueness to a pass that uses a given set of core linking variables.  The order that the 
variables appear in the FILTER_VARIABLES list doesn't affect the output.

Important: If PASSES is left blank (auto pass mode), all variables entered in FILTER_VARIABLES must have their corresponding items entered at 
the end of LINKING_VARIABLES_1, LINKING_VARIABLES_2, LINKING_VARIABLE_COMPARATORS and COMPARISON_NAMES.

Example 1:

A linking project is set up with the following parameters: 

COMPARISON_NAMES=mb sa1 day_birth month_birth year_birth sex language birthplace;

PASSES=		mb				day_birth	month_birth		year_birth		sex								+	
			mb				day_birth	month_birth		year_birth		sex		language	birthplace	+
			mb				day_birth	month_birth		year_birth		sex		language				+
			mb				day_birth	month_birth		year_birth		sex					birthplace	+
					sa1		day_birth	month_birth		year_birth		sex								+	
					sa1		day_birth	month_birth		year_birth		sex		language	birthplace	+
					sa1		day_birth	month_birth		year_birth		sex		language				+
					sa1		day_birth	month_birth		year_birth		sex					birthplace;

With the default setting, the passes are ranked in descending order of the uniqueness rate as listed in the following table.  The three passes 
that use sa1, date of birth and sex with language and/or birthplace are ranked higher than pass that uses just mb, date of birth and sex.  
However in this example, the error rates in language and birthplace are high compared to those of the other linking variables, and although the 
inclusion of one or both of these variables can raise the uniqueness rate of a pass, it may not be ideal to use them at the broader level (in 
this case sa1 day_birth month_birth sex) before making use of all the passes at the finer level (mb day_birth month_birth sex).

LINKING VARIABLES															UNIQUENESS RATE
mb 	day_birth month_birth year_birth sex language birthplace				0.999818
mb 	day_birth month_birth year_birth sex language 							0.999745
mb 	day_birth month_birth year_birth sex 		  birthplace				0.999686
sa1 day_birth month_birth year_birth sex language birthplace				0.999625
sa1 day_birth month_birth year_birth sex language							0.999571
sa1 day_birth month_birth year_birth sex 		  birthplace				0.999546
mb 	day_birth month_birth year_birth sex									0.999504
sa1 day_birth month_birth year_birth sex									0.99935

Adding the parameter setting: FILTER_VARIABLES=language birthplace;

groups the passes by the core linking variables they use and adjusts the uniqueness rates of the passes that use the filter variables.  In the
following table, the above eight passes have been divided into two groups based on their core linking variables so the MB passes are ranked 
higher than the SA1 passes.  The ranking of the passes with filter variables within each group is based on the ranking of the original 
uniqueness rates.

LINKING VARIABLES													UNIQUENESS RATE
mb 	day_birth month_birth year_birth sex language birthplace		0.999504 + 0.0000000003
mb 	day_birth month_birth year_birth sex language 					0.999504 + 0.0000000002
mb 	day_birth month_birth year_birth sex 		  birthplace		0.999504 + 0.0000000001
mb 	day_birth month_birth year_birth sex							0.999504
sa1 day_birth month_birth year_birth sex language birthplace		0.99935 + 0.0000000003
sa1 day_birth month_birth year_birth sex language 					0.99935 + 0.0000000002
sa1 day_birth month_birth year_birth sex 		  birthplace		0.99935 + 0.0000000001 
sa1 day_birth month_birth year_birth sex							0.99935	*/




%let PRIORITIES=;

/* This is ignored if the ORDER_PASSES_BY=passes or the ORDER_PASSES_BY=precision options are used.  If FILTER_VARIABLES, ORDER_PASSES_BY 
and PRIORITIES are blank, the macro ranks the passes in descending order of the pass uniqueness rate.  Otherwise this is a list using only the 
names appearing in COMPARISON_NAMES.  PRIORITIES is another option for over ruling the pass ranking set by the uniqueness rate.

Example 2:

A linking project uses two address variables which are sa1_2010 and sa1_2011 along with other supporting variables such as day_birth, 
month_birth, year_birth and sex.  Uniqueness rates for each of the passes have been calculated, with three of the uniqueness rates being

PASS NO.		LINKING VARIABLES																UNIQUENESS RATE
1				sa1_2010	sa1_2011	day_birth 	month_birth 	year_birth 	sex				0.998
2				sa1_2010				day_birth 	month_birth 	year_birth 	sex				0.997
3							sa1_2011	day_birth 	month_birth 	year_birth 	sex				0.996

By default, the macro will rank the passes with the higher uniqueness rates first.  However the data linker has a prior belief that sa1_2011 
has a lower error rate than sa1_2010 and prefers to rank passes that use sa1_2011 (eg. Pass 3) ahead of equivalent passes that instead use 
sa1_2010 (eg. Pass 2).  This may be achieved by setting PRIORITIES=sa1_2011 sa1_2010.  With this setting, each pass that uses sa1_2010 will have 
its uniqueness rate adjusted (if necessary) so that it is slightly lower than that of the same pass that instead uses sa1_2011.  

It is recommended that only one variable type is used in the priorities list (eg. just address variables or just age variables) because each 
variable in the list is prioritised over all combinations of variables that follow it in the list.  For example, with 

PRIORITIES=mb_2011 sa1_2011 mb_2010 mb_2006 sa1_2010 sa1_2006; 

a pass that uses mb_2011 is prioritised over the same pass that instead uses sa1_2011, mb_2010 and mb_2006 together.

PRIORITIES may also be used in conjunction with FILTER_VARIABLES.  For example, FILTER_VARIABLES=language birthplace and 
PRIORITIES=language birthplace to ensure that language without birthplace is used before birthplace without language within each group. */




%let STAGE_THRESHOLD=;
%let MIN_UNIQUENESS_RATE=;

/* These options are valid when ORDER_PASSES_BY, FILTER_VARIABLES, PRIORITIES, M_PROBABILITIES_GLOBAL and U_PROBABILITIES_GLOBAL are blank.  
If STAGE_THRESHOLD is blank, MIN_UNIQUENESS_RATE is ignored.  STAGE_THRESHOLD may be any number between 0 and 1.  It is usually set to a small 
number such as 0.0005.  When these parameters are used, D-MAC automatically groups the passes into stages.  Firstly, all passes are run as 
usual, links are assigned temporarily and the URs and MURs are calculated.  In the order that they are ranked (descending UR), the passes are
assessed.  If the UR differs from the MUR and smoothed MUR by more than STAGE_THRESHOLD, then the links that were assigned in the higher 
ranking (earlier passes with higher URs) are confirmed and D-MAC starts again (new stage) and recalculates URs/MURs and temporarily assigns 
links using the remaining passes and non linked records.  These remaining passes are again assessed as above and a new stage is started if 
necessary.  The process continues until the UR is less than or equal to MIN_UNIQUENESS_RATE or no more links can be assigned.  
MIN_UNIQUENESS_RATE may be any number between 0 and 1.  If it is blank when STAGE_THRESHOLD is not blank, MIN_UNIQUENESS_RATE defaults to 0.8.
*/









/* The following parameters are only used if the passes are to be automatically generated, in this case PASSES is blank.  If PASSES is not 
blank, the following parameters will be ignored.  The following parameters are constraints for the automatically generated passes. */




%let MIN_BLOCK_NO=;

/* This is used to stop the macro from running passes that are too broad and time consuming.  For any candidate pass, if the theoretical 
number of distinct non missing values in INPUT_DATASET_2 for the variables using only the EXACT comparator is less than MIN_BLOCK_NO, then the
pass won't be run.  For example, the candidate pass 'state_exact sex_exact month_exact surname_winkler', has 192 (8 x 2 x 12) theoretical 
distinct non missing values for the variables that use the exact comparator.  The pass won't be run if MIN_BLOCK_NO is greater than 192.  Due
to association between linking variables, the actual number of distinct non missing values for a pass will usually be a lot less than the 
theoretical number of distinct non missing values. 

Bigger values of MIN_BLOCK_NO result in less passes being run and usually shorter run times.  As a general rule, set MIN_BLOCK_NO to the number
of distinct non missing values in INPUT_DATSET_2 for the least discriminating pass that you intend to run.  For example if the least 
discriminating pass is 'MB AGE SEX' and this has 60 million distinct non missing values on INPUT_DATASET_2 then set MIN_BLOCK_NO=60000000. */




%let MOSTONEOF_1=;
%let MOSTONEOF_2=;
%let MOSTONEOF_3=;
%let MOSTONEOF_4=;
%let MOSTONEOF_5=;
%let MOSTONEOF_6=;
%let MOSTONEOF_7=;
%let MOSTONEOF_8=;
%let MOSTONEOF_9=;

/* Up to nine lists (of two or more items each), each using only the names appearing in COMPARISON_NAMES.  Passes are automatically generated
so that they contain at MOST one item from each list.

Example 3:

MOSTONEOF_1=mb_2010 sa1_2010 sa2_2010;
MOSTONEOF_2=mb_2011 sa1_2011 sa2_2011;
MOSTONEOF_3=age_0 age_1 birthyear_0 birthyear_1;
MOSTONEOF_4=day_exact day_missing;
MOSTONEOF_5=month_exact month_missing;

This results in no automatically generated pass: 
1. using more than one of mb_2010, sa1_2010 or sa2_2010;
2. using more than one of mb_2011, sa1_2011 or sa2_2011;
3. using more than one of age_0, age_1, birthyear_0 or birthyear_1.
4. using more than one of day_exact or day_missing.
5. using more than one of month_exact or month_missing.

So the passes 'mb_2010 sa1_2011 age_0 day_exact month_exact' and 'sa1_2011 sa2_2010 birthyear_1 day_missing month_exact' may be generated, but
the passes 'mb_2011 sa1_2011 age_0 day_exact month_exact' and 'sa1_2010 age_0 yearofbirth_1 day_exact month_exact' won't be. */




%let LEASTONEOF_1=;
%let LEASTONEOF_2=;
%let LEASTONEOF_3=;
%let LEASTONEOF_4=;
%let LEASTONEOF_5=;
%let LEASTONEOF_6=;
%let LEASTONEOF_7=;
%let LEASTONEOF_8=;
%let LEASTONEOF_9=;

/* Up to nine lists (of one or more items each), each using only the names appearing in COMPARISON_NAMES.  Passes are automatically generated
so that they contain at LEAST one item from every list.

Example 3 continued:

LEASTONEOF_1=mb_2010 sa1_2010 sa2_2010 mb_2011 sa1_2011 sa2_2011;
LEASTONEOF_2=age_0 age_1 birthyear_0 birthyear_1;
LEASTONEOF_3=day_exact day_missing;
LEASTONEOF_4=month_exact month_missing;

All passes will contain at least one form of geographic comparison (ie. mb_2010, sa1_2010, sa2_2010, mb_2011, sa1_2011 or sa2_2011) but no 
more than one geographic comparison from the same year.  All passes will agree on age or year of birth to within one year.  
Day_exact and month_exact use the exact comparator, while day_missing and month_missing use the missing comparator.  This results in no 
passes that allow explicit disagreement on day or month. */



/* END OF TEMPLATE */






























%include "&macro_location";

%dmac(input_folder_a=&input_folder_1, 
	  dataset_a=&input_dataset_1, 
	  id_a=%lowcase(&id_1), 
	  secondary_id_a=%lowcase(&secondary_id_1), 
	  variables_to_compare_a=%lowcase(&linking_variables_1),
	  input_folder_b=&input_folder_2,
	  dataset_b=&input_dataset_2, 
	  id_b=%lowcase(&id_2), 
	  secondary_id_b=%lowcase(&secondary_id_2), 
	  variables_to_compare_b=%lowcase(&linking_variables_2),
	  components=%lowcase(&comparison_names), 
	  comparators=%lowcase(&linking_variable_comparators),
	  var_lengths=&variable_lengths,
	  filter_vars=%lowcase(&filter_variables),
	  priorities=%lowcase(&priorities), 
	  prop_matches=&OVERLAP,
	  m_probs=&m_probabilities_global, 
	  u_probs=&u_probabilities_global,
	  sort_by=%lowcase(&order_passes_by),
	  group_1=%lowcase(&mostoneof_1), 
	  group_2=%lowcase(&mostoneof_2), 
	  group_3=%lowcase(&mostoneof_3), 
	  group_4=%lowcase(&mostoneof_4), 
	  group_5=%lowcase(&mostoneof_5), 
	  group_6=%lowcase(&mostoneof_6), 
	  group_7=%lowcase(&mostoneof_7),
	  group_8=%lowcase(&mostoneof_8),
	  group_9=%lowcase(&mostoneof_9),
	  critical_vars_1=%lowcase(&leastoneof_1), 
	  critical_vars_2=%lowcase(&leastoneof_2), 
	  critical_vars_3=%lowcase(&leastoneof_3), 
	  critical_vars_4=%lowcase(&leastoneof_4), 
	  critical_vars_5=%lowcase(&leastoneof_5),
	  critical_vars_6=%lowcase(&leastoneof_6),
	  critical_vars_7=%lowcase(&leastoneof_7),
	  critical_vars_8=%lowcase(&leastoneof_8),
	  critical_vars_9=%lowcase(&leastoneof_9),
	  min_block_no=&min_block_no, 
	  output_folder=&output_folder, 
	  output_flag=&output_label, 
	  agreements_folder=&working_folder, 
	  keys=%lowcase(&passes));










